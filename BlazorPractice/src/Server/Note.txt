★UnitOfWorkについて（まだちゃんとわかってないし、普通にトランザクション切れば良いと思う。複数DbContextがあるなら要りそう）
リポジトリが複数ある場合（1回の処理で複数のテーブルを更新する場合）
片方のテーブルが更新できて、もう片方が更新失敗をしてしまうと一貫性が保てない。
そこで、DbContextをラッピングしてトランザクション管理をする層を作っておく。

TIdはAuditableEntityのID、TEntityIdはIEntityのIDでどちらも一意のはず。何故両方とも各レコードに持たせているのかが分からない。
TIdでもTEntityIdでも検索できるようになっている。

★LazyCacheについて
DBのキャッシュをしている
ApplicationConstants.Cacheでキャッシュキーを生成して使う。
検索メソッドをデリゲートで書くのがポイント。GetOrAddAsyncというメソッドでキャッシュがあれば取得、無ければ第2引数のデリゲートを実行してキャッシュ登録という仕組み

★ポリシーによる認証について
Startupで行われている設定で、以下の事を行っている
・AddIdentity：ポリシー権限判定方法の設定
・AddJwtAuthentication：ポリシーの種類と判定ロジックの登録
ここで設定しているポリシーは、[Authorize(Policy = Permissions.Products.View)]みたいに使用する

★Serverプロジェクトについて
■Controllers
APIコントローラを入れるところ。
・Utilities
ExtendedAttributesControllerという汎用的なコントローラを作成して、
各Entityに共通の機能を持たせている。CRUDもこれでできる。
継承したクラスをMiscフォルダに入れる。




